/*
* This program and the accompanying materials are made available under the terms of the *
* Eclipse Public License v2.0 which accompanies this distribution, and is available at *
* https://www.eclipse.org/legal/epl-v20.html                                      *
*                                                                                 *
* SPDX-License-Identifier: EPL-2.0                                                *
*                                                                                 *
* Copyright Contributors to the Zowe Project.                                     *
*/

import {execSync} from "child_process";
import {PMFConstants} from "../PMFConstants";
import {homedir} from "os";
import * as path from "path";
import * as fs from "fs";
import {readFileSync, writeFileSync} from "jsonfile";
import {IPluginJson} from "../../doc/IPluginJson";
import {Logger} from "../../../../../logger";
import {ImperativeError} from "../../../../../error";
import {IPluginJsonObject} from "../../doc/IPluginJsonObject";
import {IO} from "../../../../../io";


/**
 * Common function that abstracts the install process. This function should be called for each
 * package that needs to be installed. (ex: `sample-cli plugin install a b c d` -> calls install 4
 * times)
 *
 * @TODO work needs to be done to support proper sharing of the plugins.json. As of now local plugins can only be reinstalled on the same machine.
 * (due to how the conversion to an absolute URI happens)
 *
 * @param {string} packageLocation A package name or location. This value can be a valid npm package
 *                                 name or the location of an npm tar file or project folder. Also,
 *                                 git URLs are also acceptable here (basically anything that `npm
 *                                 install` supports). If this parameter is a relative path, it will
 *                                 be converted to an absolute path prior to being passed to the
 *                                 `npm install` command.
 *
 * @param {string} registry The npm registry to use, this is expected to be passed by every caller
 *                          so if calling functions don't have a registry available, they need
 *                          to get it from npm.
 *
 * @param {boolean} [installFromFile=false] If installing from a file, the package location is
 *                                          automatically interpreted as an absolute location.
 *                                          It is assumed that the plugin.json file was previously
 *                                          generated by this function which always ensures an
 *                                          absolute path. Also, if this is true, we will not update
 *                                          the plugins.json file since we are not adding/modifying
 *                                          it.
 * @returns {string} The name of the plugin.
 */
export function install(packageLocation: string, registry: string, installFromFile = false): string {
    const iConsole = Logger.getImperativeLogger();
    let npmPackage = packageLocation;

    iConsole.debug(`Installing package: ${packageLocation}`);

    // Do some parsing on the package location in the case it isn't an absolute location
    // If
    //   we are not installing from a file
    //   and the location is not absolute.
    // Then
    //   we will try to convert the URI (which is a file path by the above criteria)
    //   to an absolute file path. If we can't resolve it locally, we'll leave it up to npm
    //   to do what's best.
    if (
        !installFromFile &&
        !path.isAbsolute(packageLocation)
    ) {
        const tempLocation = path.resolve(npmPackage);

        iConsole.debug(`Package is not absolute, let's see if this is a local file: ${tempLocation}`);

        // Now that we have made the location absolute...does it actually exist
        if (fs.existsSync(tempLocation)) {
            npmPackage = tempLocation;
            iConsole.info(`Installing local package: ${npmPackage}`);
        }
    }

    try {
        iConsole.debug(`Installing from registry ${registry}`);

        // We need to capture stdout but apparently stderr also gives us a progress
        // bar from the npm install.
        const pipe = ["pipe", "pipe", process.stderr];

        // Perform the npm install, somehow piping stdout and inheriting stderr gives
        // some form of a half-assed progress bar. This progress bar doesn't have any
        // formatting or colors but at least I can get the output of stdout right.
        iConsole.info("Installing packages...this may take some time.");
        const execOutput = execSync(`npm install "${npmPackage}" --prefix ${PMFConstants.instance.PLUGIN_INSTALL_LOCATION} ` +
            `-g --registry ${registry}`, {
            cwd: PMFConstants.instance.PMF_ROOT,
            stdio: pipe
        });

        iConsole.info("Install complete");

        /* We get the package name (aka plugin name)
         * from the output of the npm command.
         * The regex is meant to match: + plugin-name@version.
         */
        const stringOutput = execOutput.toString();
        const regex = /^\+\s(.*)@(.*)$/gm;
        const match = regex.exec(stringOutput);
        const packageName = match[1];
        let packageVersion = match[2];

        iConsole.debug("Reading in the current configuration.");
        const installedPlugins: IPluginJson = readFileSync(PMFConstants.instance.PLUGIN_JSON);

        // Set the correct name and version by checking if package is an npm package, this is done
        // by searching for a / or \ as those are not valid characters for an npm package, but they
        // would be for a url or local file.
        if (packageLocation.search(/(\\|\/)/) === -1) {
            // Getting here means that the package installed was an npm package. So the package property
            // of the json file should be the same as the package name.
            npmPackage = packageName;

            const passedVersionIdx = packageLocation.indexOf("@");
            if (passedVersionIdx !== -1) {
                packageVersion = packageLocation.substr(passedVersionIdx + 1);
            }
        }

        iConsole.debug(`Package version: ${packageVersion}`);

        const newPlugin: IPluginJsonObject = {
            package: npmPackage,
            registry,
            version: packageVersion
        };
        iConsole.debug("Updating the current configuration with new plugin:\n" +
            JSON.stringify(newPlugin, null, 2));

        installedPlugins[packageName] = newPlugin;

        iConsole.debug("Updating configuration file = " + PMFConstants.instance.PLUGIN_JSON);
        writeFileSync(PMFConstants.instance.PLUGIN_JSON, installedPlugins, {
            spaces: 2
        });

        // Create a symlink from home/.../imperative to brightside/.../imperative.
        linkPluginToCli(packageName);

        iConsole.info("Plugin '" + packageName + "' successfully installed.");
        return packageName;
    } catch (e) {
        throw new ImperativeError({
            msg: e.message,
            causeErrors: e
        });
    }
}

// _______________________________________________________________________
/**
 * Create links from the plugin's node_modules/@brightside directory into
 * subdirectories of the host CLI's project directory.
 *
 * @param {string} pluginName - The name of the plugin that we are installing.
 */
function linkPluginToCli(pluginName: string): void {
    const impLogger = Logger.getImperativeLogger();
    const cliProjPath = getCliProjPath();
    const pluginBsPath = createPluginBrightsideDir(pluginName);
    const linksToMake = [
        {
            pluginPath: path.join(pluginBsPath, "imperative"),
            cliPath: path.join(cliProjPath, "node_modules", "@brightside", "imperative")
        },
        {
            pluginPath: path.join(pluginBsPath, "core"),
            cliPath: cliProjPath
        }
    ];

    try {
        for (const nextLink of linksToMake) {
            if (fs.existsSync(nextLink.pluginPath)) {
                // Get the file status to determine if it is a symlink.
                const fileStats = fs.lstatSync(nextLink.pluginPath);
                if (fileStats.isSymbolicLink()) {
                    fs.unlinkSync(nextLink.pluginPath);
                    impLogger.debug("Deleted existing symbolic link = " + nextLink.pluginPath);

                    fs.symlinkSync(nextLink.cliPath, nextLink.pluginPath, "dir");
                    impLogger.debug("Created symbolic link from '" + nextLink.pluginPath +
                        "' to '" + nextLink.cliPath + "'."
                    );
                } else {
                    impLogger.error("The path '" + nextLink.pluginPath +
                        "' is not a symbolic link. So, we did not create a symlink from there to '" +
                        nextLink.cliPath + "'."
                    );
                }
            } else {
                fs.symlinkSync(nextLink.cliPath, nextLink.pluginPath, "dir");
                impLogger.debug("Created symbolic link from '" + nextLink.pluginPath +
                    "' to '" + nextLink.cliPath + "'."
                );
            }
        }
    } catch (exception) {
        throw new ImperativeError({
            msg: exception.message,
            causeErrors: exception
        });
    }
}

// _______________________________________________________________________
/**
 * Get the path to the top-level project directory of our hosting CLI.
 *
 * @returns {String} The path to CLI-dir/node_modules/@brightside/imperative
 */
function getCliProjPath() {
    const cliProjPath = path.resolve(
        path.dirname(
            require("find-up").sync(
                "package.json", {cwd: process.mainModule.filename}
            )
        )
    );
    return cliProjPath;
}

// _______________________________________________________________________
/**
 * Create the #brightside directory under the newly installed
 * plugin's node_modules directory.
 *
 * @param {string} pluginName - The name of the plugin that we are installing.
 *
 * @returns {String} The path to the new @brightside directory.
 */
function createPluginBrightsideDir(pluginName: string) {
    const pluginBsPath = path.join(PMFConstants.instance.PLUGIN_NODE_MODULE_LOCATION,
        pluginName, "node_modules", "@brightside");
    IO.mkdirp(pluginBsPath);
    return pluginBsPath;
}
